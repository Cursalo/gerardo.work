/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import React, { useRef, useEffect, useState, useMemo, forwardRef } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import type { JSX } from 'react'
import useMobileDetection from '../../hooks/useMobileDetection'
import { useThree, useFrame } from '@react-three/fiber'

// For LOD implementation, you would typically need different versions of the GLB:
// e.g., TechnoClaw_LOD0.glb (high detail), TechnoClaw_LOD1.glb (medium), TechnoClaw_LOD2.glb (low)

type GLTFResultWalking = GLTF & {
  nodes: {
    char1: THREE.SkinnedMesh
    Hips: THREE.Bone
  }
  materials: {
    // It's crucial to optimize Material_1.
    // Check texture sizes (e.g., diffuse, normal, roughness maps).
    // For mobile, aim for 1K (1024x1024) or 512x512 textures if possible.
    // Avoid very complex material features if not essential (e.g., clearcoat, transmission unless vital).
    Material_1: THREE.MeshStandardMaterial // Changed to MeshStandardMaterial for clarity, though MeshPhysicalMaterial is often the default from Blender exports.
  }
}

type GLTFResultChat = GLTF & {
  nodes: {
    char1: THREE.SkinnedMesh
    Hips: THREE.Bone
  }
  materials: {
    Material_1: THREE.MeshStandardMaterial
  }
}

type GLTFResultListening = GLTF & {
  nodes: {
    char1: THREE.SkinnedMesh
    Hips: THREE.Bone
  }
  materials: {
    Material_1: THREE.MeshStandardMaterial
  }
}

export type TechnoClawActionName =
  // | 'Armature|walking_man|baselayer' // Keep for reference, but we'll use simple names
  // | 'Armature|stand_chat|baselayer'
  // | 'Armature|listening_gesture|baselayer'
  string // Allow dynamic animation names like 'walking', 'chat', 'listening'

interface TechnoClawModelProps extends Omit<JSX.IntrinsicElements['group'], 'onClick'> {
  activeAnimationName?: TechnoClawActionName // Will now expect 'walking', 'chat', etc.
  onClick?: (event: THREE.Event) => void
  enableShadows?: boolean;
  debug?: boolean;
  visible?: boolean;
  position?: [number, number, number];
  scale?: number;
}

// Animation file paths - FIXED to use public folder paths
const ANIMATION_PATHS: Record<string, string> = { // Ensure this is Record<string, string>
  walking: '/models/technoclaw/Animation_Walking_withSkin.glb',
  chat: '/models/technoclaw/Animation_Stand_and_Chat_withSkin.glb',
  listening: '/models/technoclaw/Animation_Listening_Gesture_withSkin.glb',
  // Add other animations if NPCCharacter can send them
  idle: '/models/technoclaw/Animation_Idle_withSkin.glb',
  alert: '/models/technoclaw/Animation_Alert_withSkin.glb',
  running: '/models/technoclaw/Animation_Running_withSkin.glb'
};

// Force preload all animations
try {
  Object.entries(ANIMATION_PATHS).forEach(([name, path]) => {
    console.log(`[TechnoClawModel] Preloading animation: ${name} from ${path}`);
    useGLTF.preload(path);
  });
} catch (err) {
  console.error('[TechnoClawModel] Error preloading animations:', err);
}

// Animation clipping map to ensure consistent naming
// This map might become less critical if each file has one animation, or if animation names inside GLBs are simple.
// For now, we'll assume the activeAnimationName passed in is simple ('walking', 'chat', etc.)
/*
const ANIMATION_NAME_MAP: Record<string, TechnoClawActionName> = {
  'walking': 'Armature|walking_man|baselayer',
  // ... other mappings ...
};
*/

export const TechnoClawWalking = forwardRef<THREE.Group, TechnoClawModelProps>((props, ref) => {
  const { 
    activeAnimationName = 'walking', // Default to simple name 'walking'
    onClick, 
    enableShadows = true,
    debug = true, // Always debug for troubleshooting
    visible = true,
    position = [0, 0, -5],
    scale = 0.015, // Small scale that works well
    ...restProps 
  } = props;
  
  const localRef = useRef<THREE.Group>(null!);
  const groupRef = (ref as React.RefObject<THREE.Group>) || localRef;
  const { isMobile } = useMobileDetection();
  const { camera } = useThree();
  
  // Basic state
  const [loadError, setLoadError] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  
  // Animation state management
  const [lastAnimationName, setLastAnimationName] = useState<string>(activeAnimationName);
  const mixerRef = useRef<THREE.AnimationMixer | null>(null);
  const actionRef = useRef<THREE.AnimationAction | null>(null);
  
  // Manual path selection based on animation name
  const currentPath = useMemo(() => {
    const path = ANIMATION_PATHS[activeAnimationName.toLowerCase()];
    if (path) {
      console.log(`[TechnoClawModel] Using animation: ${activeAnimationName} from ${path}`);
      return path;
    }
    console.warn(`[TechnoClawModel] Missing animation path for "${activeAnimationName}", using walking`);
    return ANIMATION_PATHS.walking;
  }, [activeAnimationName]);
  
  // Load the GLB file directly
  const { nodes, materials, animations } = useGLTF(currentPath) as unknown as GLTFResultWalking;
  
  // Enhanced click handler with debugging
  const handleClick = (event: THREE.Intersection | any) => {
    console.log('[TechnoClaw] Model clicked!', event);
    
    // Set cursor to pointer when clicked
    document.body.style.cursor = 'pointer';
    
    // Forward the click event to parent component
    if (onClick) {
      if (event.stopPropagation) {
        event.stopPropagation();
      }
      onClick(event);
    }
  };
  
  // Initialize animation mixer and action when animations change
  useEffect(() => {
    if (!animations || animations.length === 0 || !groupRef.current) {
      console.error(`[TechnoClawModel] No animations found in ${currentPath} or missing ref`);
      return;
    }
    
    // Log animation change
    console.log(`[TechnoClawModel] Animation changed from ${lastAnimationName} to ${activeAnimationName}`);
    setLastAnimationName(activeAnimationName);
    
    // Create or get existing mixer
    if (!mixerRef.current) {
      // Ensure we have a valid object to create the mixer with
      mixerRef.current = new THREE.AnimationMixer(groupRef.current);
      console.log('[TechnoClawModel] Created new animation mixer');
    }
    const mixer = mixerRef.current;
    
    // Stop any existing animation
    if (actionRef.current) {
      actionRef.current.stop();
      console.log('[TechnoClawModel] Stopped previous animation');
    }
    
    // Get the first animation clip
    const clip = animations[0];
    console.log(`[TechnoClawModel] Found animation: ${clip.name}`);
    
    // Create and play new action
    const newAction = mixer.clipAction(clip);
    newAction.reset().play();
    actionRef.current = newAction;
    
    console.log(`[TechnoClawModel] Started playing animation: ${clip.name} for ${activeAnimationName}`);
    
    // Force animation update
    mixer.update(0.01);
    
    // Special handling for listening animation
    if (activeAnimationName === 'listening') {
      console.log('[TechnoClawModel] Applied special handling for listening animation');
      // Force multiple updates to ensure the animation is running
      mixer.update(0.016);
      mixer.update(0.016);
      
      // Set specific properties for smooth listening animation
      newAction.timeScale = 1.1; // Slightly faster
      newAction.setEffectiveWeight(1.0);
      newAction.enabled = true;
    }
    
  }, [animations, activeAnimationName, currentPath, groupRef]);
  
  // Update animation on each frame
  useFrame((_, delta) => {
    if (mixerRef.current) {
      // Clamp delta to avoid large jumps
      const clampedDelta = Math.min(delta, 0.05);
      
      // Ensure a minimum update rate for all animations
      const effectiveDelta = Math.max(clampedDelta, 0.016); // At least 60fps
      
      // Update the mixer
      mixerRef.current.update(effectiveDelta);
      
      // Special handling for listening animation to keep it moving
      if (activeAnimationName === 'listening' && actionRef.current) {
        // Force advance time for listening animation to prevent freeze
        if (actionRef.current.paused) {
          actionRef.current.paused = false;
          console.log('[TechnoClawModel] Unpaused listening animation');
        }
      }
    }
  });
  
  // If there was an error loading, show a simple red placeholder
  if (loadError) {
    console.error(`[TechnoClawModel] Error: ${errorMessage}`);
    return (
      <group ref={groupRef} position={position} scale={scale} {...restProps}>
        <mesh>
          <boxGeometry args={[1, 2, 1]} />
          <meshStandardMaterial color="red" />
        </mesh>
      </group>
    );
  }
  
  // If no nodes/materials, something went wrong
  if (!nodes || !materials) {
    console.error('[TechnoClawModel] Model may have loaded but nodes/materials missing!');
    return (
      <group ref={groupRef} position={position} scale={scale} {...restProps}>
        <mesh>
          <boxGeometry args={[1, 2, 1]} />
          <meshStandardMaterial color="orange" />
        </mesh>
      </group>
    );
  }

  // Render the actual model
  return (
    <group 
      ref={groupRef} 
      onClick={handleClick}
      onPointerUp={handleClick}
      position={position}
      scale={scale}
      {...restProps}
    >
      <group name="Scene">
        <group name="Armature" scale={1} position={[0, 0, 0]}>
          <skinnedMesh
            name="char1"
            geometry={nodes.char1.geometry}
            material={materials.Material_1}
            skeleton={nodes.char1.skeleton}
            castShadow={enableShadows}
            receiveShadow={enableShadows}
            onClick={handleClick} 
            onPointerUp={handleClick}
          />
          <primitive object={nodes.Hips} />
        </group>
      </group>
      
      {/* Add a larger invisible box for easier clicking */}
      <mesh 
        visible={false} 
        scale={[2, 4, 2]} 
        position={[0, 2, 0]} 
        onClick={handleClick}
        onPointerOver={() => {document.body.style.cursor = 'pointer'}}
        onPointerOut={() => {document.body.style.cursor = 'auto'}}
      >
        <boxGeometry args={[1, 1, 1]} />
        <meshBasicMaterial transparent opacity={0} />
      </mesh>
    </group>
  );
});

export default TechnoClawWalking;
